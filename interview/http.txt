
请求格式
POST /reg.jsp HTTP/ (CRLF)
HOST:www.guet.edu.cn (CRLF)
Content-Length:22 (CRLF)
。。。 headers
(CRLF)         //该CRLF是header和body的分隔符，下面是body，body的格式由Content-Type决定
user=jeffrey&pwd=1234  
CRLF //结束标记

响应格式
HTTP-Version Status-Code Reason-Phrase CRLF
headers
CRLF
body

Get head delete trace方法不能有请求body，所以只能通过url传递参数
Head不能有响应body
所有方法都可以在url中传递参数，url参数的最大长度由浏览器实现决定，最佳实践不超过2000
Form表单数据，如果是get，head请求，浏览器把参数放到url中，其他方法放到body中
请求body中的数据服务器怎么解析：根据content-type的值决定怎么解析
form表单数据放到body中默认是application/x-www-form-urlencoded，和url中传递的参数编码一样
Multipart/form-data,生成一个boundary来作为分隔符，还有一种text/plain主要用于工具debug协议，
是html5引入的

什么时候使用multipart：上传文件时，如果不指定multipart无法上传文件，因为urlencoded针对的是文本，
而文件是二进制的，不能编码，另外multipart的主要用途是提供boundary，但其实boundary没什么作用，
主要用作同时上传多个文件，或者应用层数据需要逻辑上的边界，和chunked的关系：chunked主要解决body内容
太大资源太重，一次性完成解析很低效，例如：传输一个超大的文件，如果server或http端可以做分段传输，实现
断点续传，还有html内容特别多，客户端可以先解析一个chunk边渲染边接受剩下的chunk。但是文件传输和大html
内容不使用chunk都可以，使用chunk只是为了效率。上传文件也可以不使用multipart，单必须使用ajax发送二进制流。


编码
Header name：必须是可打印的ascii字符，不能包含任何空格，制表符，CLRF（回车换行）
Header body:必须是ascii字符
但是如果在header name和body中想要使用非ascii字符，进行url编码就行了，编码就是用多个ascii字符表示非ascii字符
现实中浏览器，http客户端，各种httpserver对header的编码可能都有不同的实现，需要抓包分析确定；自己的httpserver需要兼容客户端浏览器对非ascii的编码方式。


utf16编码是双字节定长编码java string都是这种编码，char占两个字节，不兼容ascii
Utf8编码是变成编码，兼容ascii和iso编码

setCharacterEncoding()
该函数用来设置http请求或者相应的编码。   对于request，是指提交内容的编码，指定后可以通过getParameter()则直接获得正确的字符
串，如果不指定，则默认使用iso8859-1编码，需要进一步处理。参见下述"表单输入"。值得注意的是在执行setCharacterEncoding()之前，不能执行任何getParameter()。java doc上说明：This method must be called prior to reading request parameters or reading input using getReader()。而且，该指定只对POST方法有效，对GET方法无效。分析原因，应该是在执行第一个getParameter()的时候，java将会按照编码分析所有的提交内容，而后续的getParameter()不再进行分析，所以setCharacterEncoding()无效。而对于GET方法提交表单是，提交的内容在URL中，一开始就已经按照编码分析所有的提交内容，setCharacterEncoding()自然就无效

Urlencode的本质是把非法字符按照某种encodeing方式转为字节数组，然后把每个字节变成16进制字符
不需要编码的字符：[0-9a-zA-Z] $-_.+!*'(),     其他的任何字符都需要编码
Unsafe的字符尽量不要在url中使用，尽管他们可以被编码后传输：” < > # % { } | \ ^ ~ [ ] ` 还有空格制表符等
但是rfc协议中urlencode中要求空格被编码为+，这样url中不能传输+，因为+会被解码为空格，肯定会出错
Chrome总是把url编码为%20，而不对+进行编码

tomcat实现
核心实现在 catalina.jar  ApplicationHttpRequest

conf/server.xml Connector URIEncoding中配置了怎么解析path部分的字符串，默认ISO-8859-1
QueryString 的解码字符集要么是 Header 中 ContentType 中定义的 Charset 要么就是默认的 ISO-8859-1
要使用 ContentType 中定义的编码就要设置 connector 的 <Connector URIEncoding=”UTF-8” useBodyEncodingForURI=”true”/> 中的 useBodyEncodingForURI 设置为 true。这个配置项的名字有点让人产生混淆，它并不是对整个 URI 都采用 BodyEncoding 进行解码而仅仅是对 QueryString 使用 BodyEncoding 解码，这一点还要特别注意
header value的解码默认使用ISO-8859-1，无法设置